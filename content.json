{"meta":{"title":"Kxoo 的博客记录","subtitle":null,"description":null,"author":"ZKB","url":"http://yoursite.com"},"pages":[{"title":"Tags","date":"2018-09-07T01:50:27.000Z","updated":"2018-06-07T07:35:44.000Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2018-04-20T20:48:33.000Z","updated":"2018-06-07T07:36:37.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"mongoDB赋值新对象属性","slug":"mongoDB赋值新对象属性 ","date":"2019-02-23T13:01:03.521Z","updated":"2019-02-23T13:01:03.664Z","comments":true,"path":"2019/02/23/mongoDB赋值新对象属性 /","link":"","permalink":"http://yoursite.com/2019/02/23/mongoDB赋值新对象属性 /","excerpt":"","text":"mongoDB赋值新对象属性 mongoDB赋值新对象属性 遇到的一些坑 要点通过js 的直接对象赋值失败 解决方案通过Reflect.ownKeys 检查对象具有的属性，针对 _doc 赋值Reflect.set(res._doc, ‘checked’, 1) 详细过程直接通过属性赋值是不对的，需要的内容被嵌套在_doc 内 12345678910111213res.productNum = 1;...console.log(Reflect.ownKeys(res))[ '$__', 'isNew', 'errors', '_doc', '$init', 'productNum', 'checked' ] 解决办法1234567891011121314151617181920Goods.findOne(&#123; productId: productId &#125;) .then((res) =&gt; &#123; let doc = res Reflect.set(doc._doc, 'productNum', 1) Reflect.set(doc._doc, 'checked', 1) console.log(doc._doc) return doc &#125;)&#123; _id: 58e7053c98dab115d336b3f8,productId: '201710013',productName: 'Ear2000',salePrice: 2000,productImage: '13.jpg',productUrl: '',productNum: 1,checked: 1 &#125; 结语找了很久 不知道怎么搜索问题， 索性自己摸索出来了，诸君好运 ～","categories":[],"tags":[{"name":"nodejs express promise","slug":"nodejs-express-promise","permalink":"http://yoursite.com/tags/nodejs-express-promise/"}]},{"title":"倒计时问题 面试题","slug":"定时器","date":"2018-05-20T13:05:55.000Z","updated":"2018-06-07T06:45:22.000Z","comments":true,"path":"2018/05/20/定时器/","link":"","permalink":"http://yoursite.com/2018/05/20/定时器/","excerpt":"","text":"倒计时问题 面试题 文章说明了解决问题的两种方法 setInterval setTimeOut(有一个很基础的坑) 要点首先注意到JavaScript 是单线程的，倒计时可以说一定会因为线程阻塞而有延迟不准确。 解决方案通过获取标准时间差值做一个间隔时间判断，大于间隔时间立即执行，不再做多余等待，防止累加，小于就和间隔时间相减，作为新的间隔时间。 详细过程123456789101112131415161718192021222324var startTime = new Date().getTime();//输入参数为倒计时时间function Start(ms)&#123; console.log(startTime) var offset = new Date().getTime() - startTime; startTime = new Date().getTime(); //计算误差时间 var nextTime = 1000 - offset; //超过一千立即执行 if (nextTime &lt; 0) &#123; nextTime = 0 ; ms += nextTime &#125; ms -= 1000; console.log(\"误差：\" + offset + \"ms，下一次执行：\" + nextTime + \"ms后\"); if(ms &lt; 0)&#123; clearTimeout(timeCounter); &#125;else&#123; timeCounter = setTimeout(Start(ms),nextTime); &#125; &#125; Start(30000) 填坑 (关于setTimeOut)先想想这段代码会发生什么12345for (let i = 0; i &lt; 5; i++) &#123; setTimeout(function() &#123; console.log(new Date, i); &#125;, 1000);&#125; 结果控制台会在一秒后直接输出五次结果 (0 1 2 3 4) WHY计时器线程按照触发顺序进行记时，五次setTimeOut 记时在\b\b短时间内被触发，间隔时间不会被累加，而是被包含。\b 所以当延迟时间都是1000毫秒时，函数会在\b依次触发顺序的微小时差加上一秒在等待队列添加五遍。 拯救解决办法很简单 执行时间修改为 1000 * i ; tips\b在浏览器中，setTimeout()/setInterval() 的每调用一次定时器的最小间隔是4ms，这通常是由于函数嵌套导致（嵌套层级达到一定深度），或者是由于已经执行的setInterval的回调函数阻塞导致的。 参考文档 MDN window.setTimeout https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setTimeout 破解前端面试（80% 应聘者不及格系列）：从 闭包说起 https://zhuanlan.zhihu.com/p/25855075 How JavaScript Timers Work https://johnresig.com/blog/how-javascript-timers-work/ 你真的知道怎么用javascript来写一个倒计时吗 ? https://github.com/gomeplusFED/blog/blob/master/2016-04/do-you-really-understand-how-to-write-a-countdown-by-javascript.md","categories":[],"tags":[{"name":"setTimeOut, setInterval, JavaScript, 定时器","slug":"setTimeOut-setInterval-JavaScript-定时器","permalink":"http://yoursite.com/tags/setTimeOut-setInterval-JavaScript-定时器/"}]},{"title":"requestAnimationFrame 与通过事件池来理解JavaScript 单线程运行机制的学习总结","slug":"requestAnimationFrame 与通过事件池来理解JavaScript 单线程运行机制的学习总结 ","date":"2018-05-03T11:23:00.000Z","updated":"2018-06-07T06:44:51.000Z","comments":true,"path":"2018/05/03/requestAnimationFrame 与通过事件池来理解JavaScript 单线程运行机制的学习总结 /","link":"","permalink":"http://yoursite.com/2018/05/03/requestAnimationFrame 与通过事件池来理解JavaScript 单线程运行机制的学习总结 /","excerpt":"","text":"requestAnimationFrame 与通过事件池来理解JavaScript 单线程运行机制的学习总结首先提及进程与线程的关系 进程是CPU资源分配的最小单位（拥有资源能够独立运行） 每一个进程之间相互独立 线程是cpu调度的最小单位 线程是建立在进程的基础上的程序运行单位，一个进程中可以有多个线程 JavaScript运行相关的四个线程 GUi渲染线程 解析HTML CSS 建立DOM树 RenderObject 树，生成布局（回流）以及重绘 JavaScript引擎线程 解析JavaScript脚本， 每一个Tab页只有一个JS线程 和渲染线程互斥，执行时间过长会导致渲染加载阻塞 定时触发器线程 定时器的计数是由单独的线程来负责，避免单线程的JavaScript 引擎线程阻塞导致的计数延迟甚至不进行。 事件触发线程 控制事件循环，一旦触发相应事件，便将事件添加到队列 HTTP请求线程 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。 明确上面的概念后，我们要知道 一般同步任务都在主线程上执行，形成一个执行栈，顺序依次执行 事件触发线程管理着一个任务队列，只要异步任务（触发事件）有了运行结果，就在任务队列之中放置一个事件。 一旦执行栈中的执行栈中任务执行完毕（JavaScript 引擎空闲），JavaScript 引擎线程读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。 requestAnimationFrame 先简单理解为一个16ms的定时函数 当你的JavaScript 代码执行到这里的时候，触发定时触发器线程，开始计数，与此同时JavaScript线程继续向下执行。计时完成后添加到JavaScript 事件队列中进行排队。也就是说明记时完成后并不会迅速执行。 不过相比于setTimeout 它有更多的优点 来看MDN的解释 window.requestAnimationFrame() 方法告诉浏览器您希望执行动画并请求浏览器在下一次重绘之前调用指定的函数来更新动画。该方法使用一个回调函数作为参数，这个回调函数会在浏览器重绘之前调用。 值得注意的是回调的次数通常是每秒60次，但大多数浏览器通常匹配 W3C 所建议的刷新频率。在大多数浏览器里，当运行在后台标签页或者隐藏的&lt;iframe&gt; 里时，requestAnimationFrame() 会暂停调用以 提升性能和电池寿命 。 最后解决一下部分兼容性问题123456789101112131415161718192021222324252627282930// requestAnimationFrame polyfill by Erik Möller.// Fixes from Paul Irish, Tino Zijdel, Andrew Mao, Klemen Slavič, Darius Bacon// MIT license if (!Date.now) Date.now = function() &#123; return new Date().getTime(); &#125; (function() &#123; 'use strict'; var vendors = ['webkit', 'moz']; for (var i = 0; i &lt; vendors.length &amp;&amp; !window.requestAnimationFrame; ++i) &#123; var vp = vendors[i]; window.requestAnimationFrame = window[vp+'RequestAnimationFrame']; window.cancelAnimationFrame = (window[vp+'CancelAnimationFrame'] || window[vp+'CancelRequestAnimationFrame']); &#125; if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) // iOS6 is buggy || !window.requestAnimationFrame || !window.cancelAnimationFrame) &#123; var lastTime = 0;//初始时间为零， 第一次nextTime 取now window.requestAnimationFrame = function(callback) &#123;//返回一个setTimeout函数接受执行回调函数 var now = Date.now(); var nextTime = Math.max(lastTime + 16, now);//从当前时间和最后一次刷新的时间比较取最大 return setTimeout(function() &#123; callback(lastTime = nextTime); &#125;,//保存nextTime的值 nextTime - now);//执行时间是'现在' or 16ms 后 &#125;; window.cancelAnimationFrame = clearTimeout; &#125; &#125;());","categories":[],"tags":[{"name":"requestAnimationFrame, JavaScript, 单线程","slug":"requestAnimationFrame-JavaScript-单线程","permalink":"http://yoursite.com/tags/requestAnimationFrame-JavaScript-单线程/"}]}]}